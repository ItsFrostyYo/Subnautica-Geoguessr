<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Subnautica GeoGuessr — Web Edition (Smooth Zoom + Canvas Map)</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
<style>
  html,body{height:100%;margin:0;background:#000;color:#fff;font-family:Arial,Helvetica,sans-serif;overflow:hidden}
  #photo{position:absolute;inset:0;width:100%;height:100%;object-fit:cover;z-index:0}
  #mapContainer{position:fixed;right:20px;bottom:20px;width:420px;height:420px;border-radius:10px;border:2px solid #0ff;overflow:hidden;z-index:40;background:#00161a}
  #mapCanvas{width:100%;height:100%;display:block}
  #controlsTop{position:fixed;right:20px;bottom:450px;display:flex;justify-content:center;width:420px;z-index:60;}
  button{background:#00ffff22;border:1px solid #00ffff88;color:#fff;padding:6px 10px;border-radius:6px;margin:0;cursor:pointer;font-size:14px;}
  button:hover{background:#00ffff55;}
  #topInfo{position:fixed;top:15px;left:50%;transform:translateX(-50%);display:flex;gap:12px;align-items:center;background:#00000055;padding:8px 14px;border-radius:10px;border:1px solid #00ffff44;z-index:80;}
  #roundDisplay,#timerDisplay{background:#00ffff22;border:1px solid #00ffff88;color:#fff;padding:6px 10px;border-radius:6px;font-size:14px;user-select:none;}
  #summaryOverlay{position:fixed;inset:0;background:rgba(0,0,0,0.85);color:white;display:none;flex-direction:column;justify-content:center;align-items:center;font-size:18px;z-index:100;}
  #summaryOverlay button{margin-top:15px;font-size:16px;}
  #result{color:#cfe;margin-top:6px;position:fixed;left:20px;bottom:20px;z-index:60}
</style>
</head>
<body>
  <img id="photo" src="" alt="photo">
  <div id="mapContainer">
    <!-- canvas will be controlled by GameMap -->
    <canvas id="mapCanvas"></canvas>
  </div>

  <div id="controlsTop"><button id="submit">Submit Guess (Space)</button></div>

  <div id="topInfo">
    <div id="roundDisplay">Round 1 / 5</div>
    <div id="timerDisplay">0:00.00</div>
  </div>

  <div id="result"></div>

  <div id="summaryOverlay">
    <div id="summaryText"></div>
    <div id="summaryButtons" style="margin-top:12px;"></div>
    <button id="restartBtn" style="display:none;">Play Again</button>
  </div>

<script type="module">
import { saveScore } from './supabase.js';
import { GameMap } from './GameMap.js';

(() => {
  // constants for mapping back/forth with previous coordinate system
  const WORLD_MIN = -2048;
  const WORLD_MAX = 2048;
  const WORLD_SPAN = WORLD_MAX - WORLD_MIN; // 4096
  const MAP_WORLD_SIZE = 2048; // GameMap.worldSize

  let IMG_W = 2048, IMG_H = 2048; // new map size

  let places = [], current = 0, totalScore = 0, guess = null;
  let gameMap = null;
  let totalElapsed = 0, roundStartTime = 0, timerInterval = null;
  const times = [];
  const selectedBiome = localStorage.getItem('selectedBiome') || 'Safe Shallows';
  const username = sessionStorage.getItem("username") || "Unknown";

  let mapLocked = false;
  let roundLocked = false;
  const MAX_ROUNDS = 5;
  const MAX_SCORE_ALLOWED = 25000;

  const timerDisplay = document.getElementById('timerDisplay');
  const roundDisplay = document.getElementById('roundDisplay');
  const summaryOverlay = document.getElementById('summaryOverlay');
  const summaryText = document.getElementById('summaryText');
  const summaryButtons = document.getElementById('summaryButtons');
  const result = document.getElementById('result');
  const mapContainer = document.getElementById('mapContainer');
  const canvas = document.getElementById('mapCanvas');

  // back button
  const backBtn = document.createElement("button");
  backBtn.textContent = "Back to Menu";
  backBtn.style.position = "fixed";
  backBtn.style.top = "15px";
  backBtn.style.right = "15px";
  backBtn.style.zIndex = "999";
  backBtn.onclick = () => window.location.href = "index.html";
  document.body.appendChild(backBtn);

  // helpers
  function formatTime(ms) {
    const totalSeconds = ms / 1000;
    const minutes = Math.floor(totalSeconds / 60);
    const seconds = Math.floor(totalSeconds % 60);
    const hundredths = Math.floor((totalSeconds - Math.floor(totalSeconds)) * 100);
    return `${minutes}:${seconds.toString().padStart(2,'0')}.${hundredths.toString().padStart(2,'0')}`;
  }

  function startTimer() {
    clearInterval(timerInterval);
    roundStartTime = performance.now();
    timerInterval = setInterval(() => {
      const elapsed = performance.now() - roundStartTime;
      timerDisplay.textContent = formatTime(elapsed);
    }, 31);
  }
  function stopTimer() {
    if (timerInterval) {
      clearInterval(timerInterval);
      timerInterval = null;
      const roundElapsed = performance.now() - roundStartTime;
      totalElapsed += roundElapsed;
      times.push(roundElapsed);
      timerDisplay.textContent = formatTime(roundElapsed);
    }
  }

  // convert original world coords (wx in [-2048,2048]) -> GameMap world coords [0..2048]
  function worldToGameMapCoords(wx, wz) {
    // note: baseline used wz = -item.coords.z earlier; places will store coords already with that inversion
    const gx = ((wx - WORLD_MIN) / WORLD_SPAN) * MAP_WORLD_SIZE;
    const gy = ((wz - WORLD_MIN) / WORLD_SPAN) * MAP_WORLD_SIZE;
    return { x: gx, y: gy };
  }

  // convert from GameMap world coords -> original world coords
  function gameMapToWorldCoords(gx, gy) {
    const wx = (gx / MAP_WORLD_SIZE) * WORLD_SPAN + WORLD_MIN;
    const wz = (gy / MAP_WORLD_SIZE) * WORLD_SPAN + WORLD_MIN;
    return { x: wx, z: wz };
  }

  function distanceWorld(a, b) { return Math.hypot(a.x - b.x, a.z - b.z); }
  function scoreFromDistance(d) {
    const max = 5000;
    if (d <= 10) return max;
    const scaled = Math.max(0, max - (d - 10) * 1.25);
    return Math.round(scaled);
  }

  function disableMapInteractions() {
    // block canvas input
    if (canvas) canvas.style.pointerEvents = "none";
  }
  function enableMapInteractions() {
    if (canvas) canvas.style.pointerEvents = "auto";
  }

  // --- Load locations (convert coords to internal world coords) ---
  async function loadLocations() {
    try {
      const res = await fetch(`locations.json?cacheBust=${Date.now()}`);
      const data = await res.json();
      const biomeTarget = (selectedBiome || "").trim().toLowerCase();

      let source;
      if (biomeTarget === "entire map") {
        source = data; // use all
      } else {
        const filtered = data.filter(
          item => (item.biome || "").trim().toLowerCase() === biomeTarget
        );
        source = filtered.length ? filtered : [];
      }

      if (!source.length) {
        alert(`No locations found for "${selectedBiome}".`);
        return;
      }

      const shuffled = source.sort(() => 0.5 - Math.random());

      // convert coords: keep original-style "world coords" for scoring, but add gm coords for map display
      places = shuffled.slice(0, Math.min(MAX_ROUNDS, shuffled.length)).map(item => {
        const wx = Number(item.coords.x);             // original X
        const wz = -Number(item.coords.z);            // baseline used negative Z; keep same
        const gm = worldToGameMapCoords(wx, wz);      // map-space coords
        return {
          ...item,
          coords: { x: wx, z: wz },       // world coords kept for scoring
          gmCoords: { x: gm.x, y: gm.y }  // GameMap world coords (0..2048)
        };
      });

      totalScore = 0;
      totalElapsed = 0;
      times.length = 0;

      startRound(0);
    } catch (err) {
      alert('Could not load locations.json');
      console.error(err);
    }
  }

  // --- Map initialization ---
  function initGameMap() {
    gameMap = new GameMap(canvas, { imageSrc: "map.png", worldSize: MAP_WORLD_SIZE });

    // patch resize behavior so canvas equals the #mapContainer dimensions (keeps small fixed map)
    gameMap._externalResize = () => {
      const rect = mapContainer.getBoundingClientRect();
      // ensure integer pixel sizes
      canvas.width = Math.max(100, Math.round(rect.width));
      canvas.height = Math.max(100, Math.round(rect.height));
      gameMap._draw();
    };

    // set initial camera so whole map is visible (a comfortable zoom-out)
    // choose a target zoom that shows the full map inside the container
    // small container -> target zoom < 1 to fit; try a safe value
    gameMap.camera.targetZoom = 0.45;
    gameMap.camera.zoom = 0.45;
    gameMap.camera.x = MAP_WORLD_SIZE / 2;
    gameMap.camera.y = MAP_WORLD_SIZE / 2;

    // ensure pointer events are allowed initially
    canvas.style.pointerEvents = "auto";
  }

  // --- startRound: mirrors your baseline behavior ---
  function startRound(i) {
    if (i >= MAX_ROUNDS || i >= places.length) return;
    current = i;
    roundDisplay.textContent = `Round ${i + 1} / ${places.length}`;
    guess = null;
    result.textContent = '';
    mapLocked = false;
    roundLocked = false;
    enableMapInteractions();

    if (gameMap) {
      // clear markers
      gameMap.guessMarker = null;
      gameMap.actualMarker = null;

      // smooth fly to center and a comfortable zoom for the small container
      // center is (MAP_WORLD_SIZE/2, MAP_WORLD_SIZE/2)
      // do it by setting an anchor so GameMap handles smooth motion
      const cx = canvas.width / 2;
      const cy = canvas.height / 2;
      gameMap._zoomAnchor = { sx: cx, sy: cy, wx: MAP_WORLD_SIZE / 2, wy: MAP_WORLD_SIZE / 2 };
      // target zoom chosen to show whole map in 420x420 container; adjust easily if you want
      gameMap.camera.targetZoom = 0.21;
    }

    document.getElementById('photo').src = places[i].image;
    timerDisplay.textContent = '0:00.00';
    startTimer();
  }

  // --- summary/round flow (500ms freeze) ---
  function showSummaryRound(d, s) {
    stopTimer();
    summaryOverlay.style.display = 'flex';
    summaryText.innerHTML = `<h2>Round ${current + 1} Complete</h2><p>Distance: ${Math.round(d)} m</p><p>Score: ${s}</p><p>Loading next round...</p>`;
    roundLocked = true;
    summaryOverlay.onclick = null;
    document.removeEventListener('keydown', nextRoundKey);
    setTimeout(() => {
      roundLocked = false;
      summaryText.innerHTML = `<h2>Round ${current + 1} Complete</h2><p>Distance: ${Math.round(d)} m</p><p>Score: ${s}</p><p>Press Space or Click to Continue</p>`;
      document.addEventListener('keydown', nextRoundKey, { once: true });
      summaryOverlay.onclick = () => { document.removeEventListener('keydown', nextRoundKey); nextRound(); };
    }, 500); // 500ms freeze
  }

  function nextRoundKey(e) { if (e.code === 'Space' && !roundLocked) nextRound(); }

  function nextRound() {
    if (roundLocked) return;
    summaryOverlay.onclick = null;
    summaryOverlay.style.display = 'none';
    current++;
    if (current < places.length && current < MAX_ROUNDS) startRound(current);
    else showFinalSummary();
  }

  // --- final summary and save (reject > MAX_SCORE_ALLOWED) ---
  async function showFinalSummary() {
    const totalTimeSec = Number((totalElapsed / 1000).toFixed(2));
    summaryOverlay.style.display = 'flex';
    summaryText.innerHTML = `<h2>Game Over</h2><p>Username: ${username}</p><p>Biome: ${selectedBiome}</p><p>Total Score: ${totalScore}</p><p>Total Time: ${formatTime(totalElapsed)}</p>`;
    summaryButtons.innerHTML = '';
    if (totalScore <= MAX_SCORE_ALLOWED) {
      try { await saveScore(username, selectedBiome, totalScore, totalTimeSec); } catch (e) { console.error("Error saving score:", e); }
    } else {
      console.warn("Rejected invalid total score:", totalScore);
    }
    const again = document.createElement('button'); again.textContent = 'Play Again'; again.onclick = () => { summaryOverlay.style.display = 'none'; loadLocations(); };
    const dash = document.createElement('button'); dash.textContent = 'Return to Dashboard'; dash.onclick = () => window.location.href = 'index.html';
    summaryButtons.appendChild(again); summaryButtons.appendChild(dash);
  }

  // --- submitGuess: use GameMap.guessMarker, convert coords, lock map, show actual marker and animate ---
  function submitGuess() {
    if (mapLocked || roundLocked) return;

    if (!gameMap || !gameMap.guessMarker) { alert('Place a guess first!'); return; }

    // Immediately lock map & round
    mapLocked = true;
    roundLocked = true;
    disableMapInteractions();

    // get world coords for actual and guess (original [-2048..2048] space)
    const actualWorld = { x: places[current].coords.x, z: places[current].coords.z };
    const guessGm = gameMap.guessMarker; // in [0..MAP_WORLD_SIZE]
    const guessWorld = gameMapToWorldCoords(guessGm.x, guessGm.y); // {x,z} in [-2048..2048]

    const d = distanceWorld(actualWorld, guessWorld);
    const s = scoreFromDistance(d);
    totalScore += s;
    result.textContent = `Distance: ${Math.round(d)} m — Score: ${s}`;

    // set actual marker on the GameMap (in GameMap coords)
    const actualGm = worldToGameMapCoords(actualWorld.x, actualWorld.z);
    if (gameMap) {
      gameMap.actualMarker = { x: actualGm.x, y: actualGm.y };
      // animate smoothly to the actual marker and zoom in a bit
      const cx = canvas.width / 2;
      const cy = canvas.height / 2;
      // decide a zoom-in target (bigger than default). These values are tuned to container size.
      gameMap._zoomAnchor = { sx: cx, sy: cy, wx: actualGm.x, wy: actualGm.y };
      // zoom in moderately
      gameMap.camera.targetZoom = Math.min(gameMap.maxZoom, 1.6);
    }

    // small delay before showing summary (preserve baseline feel)
    setTimeout(() => showSummaryRound(d, s), 400);
  }

  // --- init map & load ---
  initGameMap();
  loadLocations();

  // submit and spacebar handlers
  document.getElementById('submit').addEventListener('click', submitGuess);
  document.addEventListener('keydown', e => {
    if (e.code === 'Space' && summaryOverlay.style.display === 'none' && !roundLocked) submitGuess();
  });

  // expose for debugging if needed
  window.__SubnauticaGameMap = { gameMap, worldToGameMapCoords, gameMapToWorldCoords };
})();
</script>
</body>
</html>
